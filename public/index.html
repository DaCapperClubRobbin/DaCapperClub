<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>DaCapperClub</title>

  <style>
    body { margin:0; font-family: Arial, sans-serif; background:#0b0b0f; color:#fff; }
    a { color:#7dd3fc; }

    header { padding:16px 20px; border-bottom:1px solid #222; display:flex; justify-content:space-between; align-items:center; }
    .sub { margin-top:4px; color:#aaa; font-size:12px; }
    .right { display:flex; align-items:center; gap:8px; }
    .dot {
      width:10px; height:10px; border-radius:999px;
      background:#22c55e;
      box-shadow:0 0 10px rgba(34,197,94,.6);
    }

    .layout { display:flex; min-height: calc(100vh - 57px); }

    .sidebar {
      width: 260px;
      border-right: 1px solid #222;
      background: #0e0e13;
      padding: 14px;
      box-sizing: border-box;
      overflow-y: auto;
    }

    .sidebar h3 {
      margin: 0 0 10px 0;
      font-size: 12px;
      color: #aaa;
      text-transform: uppercase;
      letter-spacing: .08em;
    }

    .capper {
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:10px 10px;
      border-radius:12px;
      cursor:pointer;
      border:1px solid transparent;
    }
    .capper:hover { background:#14141b; }
    .capper.active { background:#14141b; border-color:#2a2a2a; }

    .capper-left { display:flex; align-items:center; gap:10px; min-width:0; }
    .capper-name { font-weight:700; font-size:14px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
    .capper-right { display:flex; align-items:center; gap:8px; }
    .capper-count { color:#aaa; font-size:12px; }

    /* üî¥ Unread badge */
    .badge {
      min-width: 22px;
      height: 18px;
      padding: 0 6px;
      border-radius: 999px;
      background: #ef4444;
      color: white;
      font-size: 12px;
      font-weight: 800;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
    }

    .main {
      flex:1;
      padding: 18px;
      box-sizing: border-box;
      overflow-y: auto;
      max-height: calc(100vh - 57px);
    }

    .wrap { max-width: 900px; margin: 0 auto; }

    .controls { display:flex; gap:10px; margin-bottom:14px; }
    input, select { padding:10px; border-radius:10px; border:1px solid #2a2a2a; background:#111; color:#fff; width:100%; }
    select { width:200px; }

    .card {
      background: #111;
      border: 1px solid #222;
      border-radius: 14px;
      padding: 14px;
      margin-bottom: 14px;

      /* premium elevation */
      box-shadow: 0 6px 18px rgba(0, 0, 0, 0.35);
      transition: transform 0.15s ease, box-shadow 0.15s ease;
    }

    .card:hover {
      transform: translateY(-1px);
      box-shadow: 0 10px 28px rgba(0, 0, 0, 0.45);
    }

    /* top row layout */
    .top{
      display:flex;
      justify-content:space-between;
      align-items:flex-start;  /* keeps actions pinned to top */
      gap:12px;
    }

    .card-actions{
      display:flex;
      align-items:center;
      gap:8px;
      margin-top:2px;
      flex-shrink:0;
    }

    /* sport pill */
    .tag{
      display:inline-flex;
      align-items:center;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,0.12);
      background: rgba(17,17,17,0.85);
      color:#dfe3ff;
      font-size:12px;
      font-weight:800;
      letter-spacing:.2px;
      white-space:nowrap;
      box-shadow: 0 4px 14px rgba(0,0,0,0.25);
    }

    /* mod pills */
    .mod-pill{
      display:inline-flex;
      align-items:center;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,0.12);
      background: rgba(17,17,17,0.85);
      color:#dfe3ff;
      font-size:12px;
      font-weight:800;
      cursor:pointer;
      white-space:nowrap;
      transition: transform .12s ease, box-shadow .12s ease, border-color .12s ease;
      box-shadow: 0 4px 14px rgba(0,0,0,0.25);
    }

    .mod-pill:hover{
      transform: translateY(-1px);
      border-color: rgba(88,101,242,0.55);
      box-shadow: 0 10px 24px rgba(0,0,0,0.35);
    }

    .mod-pill:active{
      transform: translateY(0px);
    }

    /* unhide = green success state */
    .mod-pill.unhide{
      border-color: rgba(34,197,94,0.35);
    }
    .mod-pill.unhide:hover{
      border-color: rgba(34,197,94,0.65);
    }

    /* ===================================== */
    /* üñ±Ô∏è Desktop-only interactive polish    */
    /* ===================================== */

    @media (hover: hover) and (pointer: fine) {
      .card {
        cursor: pointer;
      }

      .card:hover .name {
        text-decoration: underline;
        text-underline-offset: 3px;
      }
    }

    /* ===================================== */
    /* ‚ú® Premium Feed Polish (App Feel)      */
    /* ===================================== */

    /* Slightly richer surface behind cards */
    .main {
      background:
        radial-gradient(1200px 600px at 50% -200px, rgba(88,101,242,0.10), rgba(0,0,0,0)),
        linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0));
    }

    /* Feed container spacing feels more "app" */
    .wrap {
      max-width: 900px;
      padding: 6px 0;
    }

    /* Cards: softer border, cleaner surface, better depth */
    .card {
      background: rgba(17,17,17,0.92);
      border: 1px solid rgba(255,255,255,0.08);
      border-radius: 16px;
      padding: 16px;
      margin-bottom: 14px;

      box-shadow:
        0 10px 30px rgba(0,0,0,0.45),
        inset 0 1px 0 rgba(255,255,255,0.03);

      transition: transform 0.15s ease, box-shadow 0.15s ease, border-color 0.15s ease;
      backdrop-filter: blur(6px);
    }

    /* hover lift: more "native app" */
    .card:hover {
      transform: translateY(-2px);
      border-color: rgba(88,101,242,0.22);
      box-shadow:
        0 16px 44px rgba(0,0,0,0.55),
        0 0 0 1px rgba(88,101,242,0.10);
    }

    /* Title + meta typography polish */
    .name {
      font-weight: 800;
      font-size: 15px;
      letter-spacing: 0.2px;
    }

    .meta {
      margin-top: 2px;
      font-size: 12px;
      color: rgba(255,255,255,0.70);
    }

    /* Content readability */
    .content {
      margin-top: 10px;
      font-size: 14px;
      line-height: 1.45;
      color: rgba(255,255,255,0.92);
    }

    /* Give pills a slightly more premium surface */
    .tag,
    .mod-pill {
      background: rgba(20,20,26,0.82);
      border: 1px solid rgba(255,255,255,0.10);
    }

    /* ===================================== */
    /* ‚ú® NEW PICK PULSE / GLOW (BRAND)       */
    /* ===================================== */

    @keyframes pulseGlow {
      0% {
        box-shadow: 0 0 0 rgba(88,101,242,0);
        border-color: #222;
      }
      40% {
        box-shadow: 0 0 18px rgba(88,101,242,0.45);
        border-color: rgba(88,101,242,0.7);
      }
      100% {
        box-shadow: 0 0 0 rgba(88,101,242,0);
        border-color: #222;
      }
    }

    /* runs until JS removes .new-pick (15s) */
    .card.new-pick {
      animation: pulseGlow 1.4s ease-in-out infinite;
      background: linear-gradient(
        180deg,
        rgba(88,101,242,0.045),
        rgba(0,0,0,0)
      );
    }

    /* ===================================== */
    /* üö´ Hidden pick styling (mods only)    */
    /* ===================================== */

    .card.is-hidden {
      opacity: 0.55;
      border-color: rgba(239,68,68,0.35);
      background: rgba(60, 0, 0, 0.15);
    }

    .card.is-hidden .name::after {
      content: " (Hidden)";
      font-size: 12px;
      font-weight: 600;
      color: #ef4444;
    }

    /* ===================================== */
    /* ‚ú® Capper glow when unread (brand)     */
    /* ===================================== */

    .capper.unread {
      border-color: rgba(88, 101, 242, 0.45);
      box-shadow: 0 0 0 rgba(88, 101, 242, 0);
    }

    .capper.unread .capper-name {
      color: #dfe3ff;
      text-shadow:
        0 0 8px rgba(88, 101, 242, 0.30),
        0 0 14px rgba(88, 101, 242, 0.18);
    }

    /* ===================================== */
    /* üü¢ PICKS LOADED INDICATOR (GREEN)      */
    /* ===================================== */

    .live-indicator {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .live-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: #22c55e; /* ALWAYS GREEN */
      box-shadow: 0 0 10px rgba(34,197,94,0.55);
      animation: greenPulse 1.6s ease-in-out infinite;
    }

    /* idle green pulse */
    @keyframes greenPulse {
      0%   { box-shadow: 0 0 0 rgba(34,197,94,0); }
      50%  { box-shadow: 0 0 12px rgba(34,197,94,0.55); }
      100% { box-shadow: 0 0 0 rgba(34,197,94,0); }
    }

    .live-text {
      font-size: 14px;
      font-weight: 700;
      color: #dfe3ff;
      letter-spacing: 0.3px;
    }

    /* flash on new pick */
    .live-dot.flash {
      animation: greenFlash 0.85s ease-out !important;
    }

    @keyframes greenFlash {
      0%   { transform: scale(1); box-shadow: 0 0 0 rgba(34,197,94,0); }
      45%  { transform: scale(1.55); box-shadow: 0 0 22px rgba(34,197,94,0.95); }
      100% { transform: scale(1); box-shadow: 0 0 0 rgba(34,197,94,0); }
    }

   /* ===================================== */
   /* üñºÔ∏è Embed image sizing + click expand   */
   /* ===================================== */

   .embedImg {
     width: 100%;
     max-height: 320px;      /* controls how tall embeds can be */
     object-fit: cover;
     border-radius: 12px;
     margin-top: 10px;
     cursor: zoom-in;
   }

   .embedImg.expanded {
     max-height: none;
     object-fit: contain;
     cursor: zoom-out;
   }

   /* ===================================== */
   /* üè∑Ô∏è Brand header (logo + name)          */
   /* ===================================== */

   .brand {
     display: flex;
     align-items: center;
     gap: 10px;
   }

   .brandLogo {
     height: 28px;
     width: auto;
   }

   .brandName {
     color: #dfe3ff; /* soft discord-tinted white */
     font-weight: 800;
     font-size: 18px;
     letter-spacing: 0.3px;

     /* VERY subtle glow */
     text-shadow:
       0 0 6px rgba(88, 101, 242, 0.25),
       0 0 12px rgba(88, 101, 242, 0.15);
   }

   /* ===================================== */
   /* ‚ûñ Subtle divider between cards         */
   /* ===================================== */
   .card {
     position: relative; /* needed for the divider */
   }

   .card:not(:last-child)::after {
     content: "";
     position: absolute;
     left: 16px;
     right: 16px;
     bottom: -10px;
     height: 1px;
     background: rgba(255,255,255,0.06);
   }

   /* ===================================== */
   /* üîí Lock page scroll (sidebar + feed)  */
   /* ===================================== */

   html, body {
     height: 100%;
     margin: 0;
   }

   body {
     overflow: hidden;              /* only sidebar + main scroll */
     display: flex;
     flex-direction: column;
   }

   header {
     flex: 0 0 auto;
   }

   .layout {
     flex: 1 1 auto;
     min-height: 0;                 /* IMPORTANT: allows inner scrolling */
     overflow: hidden;
   }

   .sidebar {
     overflow-y: auto;
     height: 100%;
   }

   .main {
     overflow-y: auto;
     height: 100%;
     max-height: none;
     -webkit-overflow-scrolling: touch;
   }

   /* ===================================== */
   /* üß≠ Scrollbars (sidebar + feed)         */
   /* ===================================== */

   /* Sidebar (keep how you like it) */
   .sidebar::-webkit-scrollbar { width: 12px; }
   .sidebar::-webkit-scrollbar-track { background: transparent; }
   .sidebar::-webkit-scrollbar-thumb{
     background: rgba(255,255,255,0.22);
     border-radius: 999px;
     border: 3px solid transparent;
     background-clip: content-box;
   }
   .sidebar::-webkit-scrollbar-thumb:hover{
     background: rgba(255,255,255,0.38);
   }

   /* Feed (picks area) bigger + brand */
   .main::-webkit-scrollbar { width: 18px; }
   .main::-webkit-scrollbar-track { background: rgba(255,255,255,0.04); }
   .main::-webkit-scrollbar-thumb{
     background: rgba(88,101,242,0.55);
     border-radius: 999px;
     border: 4px solid transparent;
     background-clip: content-box;
   }
   .main::-webkit-scrollbar-thumb:hover{
     background: rgba(88,101,242,0.85);
   }

   /* Firefox */
   .sidebar{
     scrollbar-width: auto;
     scrollbar-color: rgba(255,255,255,0.35) transparent;
   }
   .main{
     scrollbar-width: auto;
     scrollbar-color: rgba(88,101,242,0.70) transparent;
   }

  </style>
</head>

<body>
  <header>
    <div>
      <div class="brand">
        <img class="brandLogo" src="/dacapperclub-logo.png" alt="DaCapperClub" />
        <span class="brandName">DaCapperClub</span>
      </div>
    </div>

    <div class="right live-indicator">
      <span class="live-dot"></span>
      <span class="live-text">
        Picks Loaded ‚Ä¢ <span id="loadedCount">0</span>
      </span>
    </div>

      <!-- Mod login button -->
      <button
        id="modBtn"
        style="
          padding: 8px 10px;
          border-radius: 10px;
          border: 1px solid #2a2a2a;
          background: #111;
          color: #fff;
          cursor: pointer;
          font-size: 12px;
        "
     >
        Mod
      </button>
    </div>
  </header>

  <div class="layout">
    <aside class="sidebar">
      <h3>Cappers</h3>
      <div id="capperList"></div>
    </aside>

    <main class="main">
      <div class="wrap">
        <div class="controls">
          <input id="search" placeholder="Search capper or pick text..." />
          <select id="sport">
            <option value="">All Sports</option>
            <option>CFB</option>
            <option>Esports</option>
            <option>Foreign Sports</option>
            <option>MLB</option>
            <option>MMA</option>
            <option>NBA</option>
            <option>NCAAB</option>
            <option>NFL</option>
            <option>NHL</option>
            <option>Soccer</option>
            <option>Tennis</option>
            </select>
            </div>

            <div id="feed"></div>

            </div>
            </main>
            </div>

  <script>
    const feed = document.getElementById("feed");
    const searchEl = document.getElementById("search");
    const sportEl = document.getElementById("sport");
    const capperListEl = document.getElementById("capperList");

    let selectedCapper = ""; // "" means All

    // ==================================================
    // MOD MODE (store token locally in browser)
    // ==================================================
    const MOD_KEY = "dacapperclub_mod_token_v1";
    let modToken = localStorage.getItem(MOD_KEY) || "";

    function isMod() {
      return !!modToken;
    }

    const modBtn = document.getElementById("modBtn");

    if (modBtn) {
      // hide mod button by default (normal users never see it)
      modBtn.style.display = "none";

      // show mod button if already logged in
      if (modToken) {
        modBtn.style.display = "inline-block";
      }

      // secret key combo: Shift + M reveals mod button
      document.addEventListener("keydown", (e) => {
        if (e.shiftKey && e.key.toLowerCase() === "m") {
          modBtn.style.display = "inline-block";
        }
      });

      // clicking Mod button toggles mod mode
      modBtn.addEventListener("click", () => {
        const input = prompt(
          modToken
            ? "Mod mode is ON.\n\nEnter new token to replace it, or leave blank to log out:"
            : "Enter mod token:"
        );

        if (input === null) return; // user cancelled

        const trimmed = input.trim();

        if (!trimmed) {
          // logout
          modToken = "";
          localStorage.removeItem(MOD_KEY);
          modBtn.style.display = "none";
          alert("Mod mode disabled.");
        } else {
          // login
          modToken = trimmed;
          localStorage.setItem(MOD_KEY, modToken);
          modBtn.style.display = "inline-block";
          alert("Mod mode enabled.");
        }

        // re-render so Hide buttons appear/disappear
        render(cache);
      });
    }
    // ==================================================
    // -------------------------------------
    // Normalize picks coming from /picks
    // (handles camelCase vs snake_case)
    // -------------------------------------
    function normalizePick(p) {
      const created =
        p.received_at ??
        p.created_at ??
        p.createdAt ??
        null;

      return {
        id:
          p.id ??
          p.message_id ??
          p.messageId ??
          created ??
          `${p.authorId || p.author_id || "x"}-${Date.now()}`,

        author_name:
          p.author_name ??
          p.authorName ??
          p.author ??
          "Unknown",

        channel_name:
          p.channel_name ??
          p.channelName ??
          p.channel ??
          "",

        content: p.content ?? "",
        received_at: created,

        attachments: Array.isArray(p.attachments)
          ? p.attachments.map((a) => ({
              ...a,
              contentType:
                a.contentType ??
                a.content_type ??
                "",
            }))
          : [],

        embeds: Array.isArray(p.embeds)
          ? p.embeds
          : [],

        // ‚úÖ ADD THIS LINE
        hidden: p.hidden === true || p.is_hidden === true || p.hidden_at != null,
      };
    }

    // ---- NEW PICK GLOW TRACKING ----
    const NEW_IDS = new Set();

    function markNewPicks(newOnes) {
      // üü¢ Flash LIVE dot when new picks arrive
      const dot = document.querySelector(".live-dot");
      if (dot) {
        dot.classList.remove("flash");
        void dot.offsetWidth; // restart animation
        dot.classList.add("flash");
        setTimeout(() => dot.classList.remove("flash"), 900);
      }

      for (const p of newOnes) {
        if (p?.id == null) continue;
        if (NEW_IDS.has(p.id)) continue;
        NEW_IDS.add(p.id);
      }

      setTimeout(() => {
        for (const p of newOnes) {
          if (p?.id != null) NEW_IDS.delete(p.id);
        }
        render(cache);
      }, 15000);
    }

    // ---- Persist UI state (localStorage) ----
    const UI_KEY = "dacapperclub_ui_v1";

    function loadUI() {
      try {
        return JSON.parse(localStorage.getItem(UI_KEY) || "{}");
      } catch {
        return {};
      }
    }

    function saveUI(patch) {
      const current = loadUI();
      const next = { ...current, ...patch };
      localStorage.setItem(UI_KEY, JSON.stringify(next));
    }

    // ---- UNREAD INDICATORS PER CAPPER ----
    function getUnread() {
      const ui = loadUI();
      return ui.unread || {};
    }

    function setUnread(unreadObj) {
      saveUI({ unread: unreadObj });
    }

    function incUnread(name, by = 1) {
      const unread = getUnread();
      unread[name] = (unread[name] || 0) + by;
      setUnread(unread);
    }

    function clearUnread(name) {
      const unread = getUnread();
      delete unread[name];
      setUnread(unread);
    }

    // Restore UI state on load
    const ui = loadUI();
    selectedCapper = ui.capper ?? "";
    searchEl.value = ui.search ?? "";
    sportEl.value = ui.sport ?? "";

    function scrollToTop() {
      window.scrollTo({ top: 0, behavior: "smooth" });
      document.querySelector(".main")?.scrollTo({ top: 0, behavior: "smooth" });
    }

    function guessSport(text) {
      const t = (text || "").toLowerCase();

      if (
        t.includes("tennis") ||
        t.includes("atp") ||
        t.includes("wta") ||
        t.includes("grand slam") ||
        t.includes("us open") ||
        t.includes("french open") ||
        t.includes("wimbledon") ||
        t.includes("australian open")
      ) return "Tennis";

      if (t.includes("nba")) return "NBA";
      if (t.includes("nfl")) return "NFL";
      if (t.includes("cfb")) return "CFB";
      if (t.includes("ncaab") || t.includes("cbb")) return "NCAAB";
      if (t.includes("mlb")) return "MLB";
      if (t.includes("nhl")) return "NHL";
      if (t.includes("soccer")) return "Soccer";
      if (t.includes("mma") || t.includes("ufc")) return "MMA";
      if (t.includes("esports")) return "Esports";
      if (
        t.includes("foreign") ||
        t.includes("kbl") ||
        t.includes("cba") ||
        t.includes("nbl") ||
        t.includes("kbo")
      ) return "Foreign Sports";
    }

    // -------------------------------------
    // Extra sport detection text sources
    // (channel_name + content + embeds + filenames)
    // -------------------------------------
    function pickSearchText(p) {
      const parts = [];

      parts.push(p.channel_name || "");
      parts.push(p.author_name || "");
      parts.push(p.content || "");

      // embeds: title/description/fields
      if (Array.isArray(p.embeds)) {
        for (const e of p.embeds) {
          if (!e) continue;
          parts.push(e.title || "");
          parts.push(e.description || "");
          if (Array.isArray(e.fields)) {
            for (const f of e.fields) {
              if (!f) continue;
              parts.push(f.name || "");
              parts.push(f.value || "");
            }
          }
        }
      }

      // attachments: filenames can contain hints
      if (Array.isArray(p.attachments)) {
        for (const a of p.attachments) {
          if (!a) continue;
          parts.push(a.filename || "");
        }
      }

      return parts.join(" ");
   }

    function escapeHtml(str) {
      return (str || "")
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
    }

    /* ===================================== */
    /* üîó Shorten + clean embed URLs          */
    /* ===================================== */
    function linkifyAndShorten(text) {
      if (!text) return "";

      return escapeHtml(text).replace(/(https?:\/\/[^\s]+)/g, (url) => {
        const short = url.includes("outlier.bet")
          ? "View on Outlier ‚Üí"
          : "Open link ‚Üí";

        return `<a href="${url}" target="_blank" rel="noopener noreferrer">${short}</a>`;
      });
    }

    /* ===================================== */
    /* üß© Discord Embed Renderer             */
    /* ===================================== */
    function renderEmbed(e) {
      if (!e) return "";

      const title = e.title
        ? `<div class="embedTitle">${escapeHtml(e.title)}</div>`
        : "";

      const desc = e.description
        ? `<div class="embedDesc">${linkifyAndShorten(e.description)}</div>`
        : "";

      const url = e.url
  ? `<a class="embedLink" href="${e.url}" target="_blank" rel="noopener noreferrer">Open</a>`
        : "";

      const thumb = e.thumbnail?.url
        ? `<img class="embedThumb" src="${e.thumbnail.url}" />`
        : "";

      const img = e.image?.url
        ? `<img class="embedImg" src="${e.image.url}" />`
        : "";

      const fields =
        Array.isArray(e.fields) && e.fields.length
        ? `
            <div class="embedFields">
              ${e.fields
                .map(
                  (f) => `
                <div class="embedField">
                <div class="embedFieldName">
                  ${escapeHtml(f.name || "")}
                </div>
                <div class="embedFieldValue">
                  ${escapeHtml(f.value || "")}
                </div>
              </div>
            `
              )
              .join("")}
          </div>
        `
        : "";

    return `
      <div class="embedBox">
        <div class="embedTop">
          <div class="embedText">
            ${title}
            ${desc}
            ${fields}
            ${url}
          </div>
          ${thumb}
        </div>
        ${img}
      </div>
    `;
  }

    function timeAgo(dateString) {
      if (!dateString) return "";

      const now = new Date();
      const then = new Date(dateString);
      const diffMs = now - then;

      const seconds = Math.floor(diffMs / 1000);
      const minutes = Math.floor(seconds / 60);
      const hours   = Math.floor(minutes / 60);
      const days    = Math.floor(hours / 24);

      if (seconds < 60) return "just now";
      if (minutes < 60) return `${minutes} min${minutes > 1 ? "s" : ""} ago`;
      if (hours < 24)   return `${hours} hour${hours > 1 ? "s" : ""} ago`;
      if (days < 7)     return `${days} day${days > 1 ? "s" : ""} ago`;

      return then.toLocaleDateString();
    }

    function stripDiscordMentions(text) {
      return (text || "")
        .replace(/<@&\d+>/g, "")   // role mentions
        .replace(/<@!?\d+>/g, "")  // user mentions
        .replace(/<#\d+>/g, "");   // channel mentions
    }

    /* ================================ */
    /* üîó Shorten long links in content */
    /* ================================ */
    function linkifyAndShortenContent(text) {
      if (!text) return "";

      return text.replace(/(https?:\/\/[^\s<]+)/g, (url) => {
        let label = "Open link ‚Üí";

        if (url.includes("playbook.actionnetwork.com")) label = "Open Action Network ‚Üí";
        else if (url.includes("scoresandodds.com")) label = "View Scores & Odds ‚Üí";
        else if (url.includes("fanduel.com")) label = "Open FanDuel ‚Üí";
        else if (url.includes("draftkings.com")) label = "Open DraftKings ‚Üí";

        return `<a href="${url}" target="_blank" rel="noreferrer">${label}</a>`;
      });
    }

    function formatContent(raw) {
      // remove mentions first
      let s = stripDiscordMentions(raw);

      // escape HTML so nothing unsafe can execute
      s = escapeHtml(s);

      // markdown links: [text](url)
      s = s.replace(
        /\[([^\]]+)\]\((https?:\/\/[^\s)]+)\)/g,
        (m, text, url) =>
          `<a href="${url}" target="_blank" rel="noreferrer">${text}</a>`
      );

      // üîó shorten + clean ALL remaining links
      s = linkifyAndShortenContent(s);

      // line breaks
      s = s.replace(/\n/g, "<br>");

      return s;
    }

    function buildCappers(picks) {
      if (!capperListEl) return;

      const unread = getUnread();

      const counts = new Map();
      for (const p of picks) {
        const name = p.channel_name || "Unknown";
        counts.set(name, (counts.get(name) || 0) + 1);
      }

      // These cappers should always be at the bottom
      const PIN_TO_BOTTOM = new Set([
        "nba insights",
        "ncaamb insights",
        "mlb insights",
        "nhl insights",
        "nfl insights",
      ]);

      function sortKey(name) {
        return (name || "")
          .normalize("NFKD")
          .trim()
          .replace(/^[^\p{L}\p{N}]+/gu, "") // strip emojis/symbols at start
          .replace(/[-_]+/g, " ")           // normalize hyphens/underscores
          .replace(/\s+/g, " ")             // collapse spaces
          .toLowerCase();
      }


      const ordered = Array.from(counts.keys())
        .filter((name) => name && name !== "All")
        .sort((a, b) => {
          const aKey = sortKey(a);
          const bKey = sortKey(b);

          const aPinned = aKey.includes("insights");
          const bPinned = bKey.includes("insights");

          // Push pinned items to bottom
          if (aPinned && !bPinned) return 1;
          if (!aPinned && bPinned) return -1;

          return aKey.localeCompare(bKey, undefined, { sensitivity: "base" });
        });

      capperListEl.innerHTML = `
        <div class="capper ${selectedCapper === "" ? "active" : ""}" data-name="">
          <div class="capper-left">
            <span class="capper-name">All</span>
          </div>
          <div class="capper-right">
            <span class="capper-count">${picks.length}</span>
          </div>
        </div>

        ${ordered.map((name) => {
          const u = unread[name] || 0;

          return `
            <div class="capper ${u ? "unread" : ""} ${selectedCapper === name ? "active" : ""}"
                 data-name="${escapeHtml(name)}">
              <div class="capper-left">
                <span class="capper-name">${escapeHtml(name)}</span>
              </div>
              <div class="capper-right">
                ${u ? `<span class="badge">${u}</span>` : ""}
                <span class="capper-count">${counts.get(name) || 0}</span>
              </div>
            </div>
          `;
        }).join("")}

      `;

      capperListEl.querySelectorAll(".capper").forEach((el) => {
        el.addEventListener("click", () => {
          selectedCapper = el.dataset.name || "";

          if (selectedCapper) clearUnread(selectedCapper);

          saveUI({
            capper: selectedCapper,
            search: searchEl.value,
            sport: sportEl.value,
          });

          buildCappers(cache);
          render(cache);
          scrollToTop();
        });
      });
    }

    function render(picks) {
      const q = searchEl.value.trim().toLowerCase();
      const sportFilter = sportEl.value;

      const filtered = picks.filter((p) => {
        const channel = (p.channel_name || "").toLowerCase();
        const author  = (p.author_name || "").toLowerCase();
        const content = (p.content || "").toLowerCase();

        // search should match what you display (channel_name) + author + content
        const combined = channel + " " + author + " " + content;
        const matchesSearch = !q || combined.includes(q);

        const sport = guessSport(pickSearchText(p)) || "";
        const matchesSport = !sportFilter || sport === sportFilter;

        // sidebar capper filter
        const matchesCapper =
          !selectedCapper ||
          (p.channel_name || "Unknown") === selectedCapper;

        return matchesSearch && matchesSport && matchesCapper;
      });

      feed.innerHTML = filtered.map((p) => {
        const when = p.received_at ? timeAgo(p.received_at) : "";

        const sport = guessSport(pickSearchText(p)) || "";

        const attachments = Array.isArray(p.attachments) ? p.attachments : [];
        const imgs = attachments
          .filter((a) => (a.contentType || "").startsWith("image/"))
          .map((a) => `
            <div style="margin-top:10px">
              <img
                src="${a.url}"
                alt="${escapeHtml(a.filename || "image")}"
                loading="lazy"
                style="width:100%; max-height:520px; object-fit:contain; border-radius:12px; border:1px solid #222;"
              />
            </div>
          `)
          .join("");

        const isHidden = !!p.hidden;

        const isNew = NEW_IDS.has(p.id);
        return `
          <div class="card ${isNew ? "new-pick" : ""} ${isHidden ? "is-hidden" : ""}">
            <div class="top">
              <div>
                <div class="name">${escapeHtml(p.channel_name || "Unknown Capper")}</div>
                <div class="meta">By ${escapeHtml(p.channel_name || "Unknown")} ‚Ä¢ ${escapeHtml(when)}</div>
              </div>

              <div class="card-actions">
                ${sport ? `<span class="tag">${escapeHtml(sport)}</span>` : ""}

                ${
                  isMod()
                    ? isHidden
                      ? `<button class="mod-pill unhide" data-unhide="${p.id}">Unhide</button>`
                      : `<button class="mod-pill hide" data-hide="${p.id}">Hide</button>`
                    : ""
                }
              </div>
            </div>

            <div class="content">${formatContent(p.content || "")}</div>
            ${
              Array.isArray(p.embeds)
                ? p.embeds.map(renderEmbed).join("")
                : ""
            }

            ${imgs}
          </div>
        `;
      }).join("");

      // ================================
      // MOD: bind Hide buttons
      // ================================
      if (isMod()) {
        // ---- HIDE ----
        feed.querySelectorAll("[data-hide]").forEach((btn) => {
          btn.addEventListener("click", async () => {
            const id = btn.getAttribute("data-hide");
            if (!id) return;

            if (!confirm("Hide this pick for ALL users?")) return;
            const reason = prompt("Reason (optional):") || "";

            try {
              const res = await fetch("/admin/hide", {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                  "x-mod-token": modToken,
                },
                body: JSON.stringify({ id, reason }),
              });

              const out = await res.json().catch(() => ({}));
              if (!res.ok) throw new Error(out.error || "Hide failed");

              // ‚úÖ instant UI: mark hidden in cache
              cache = cache.map((p) =>
                String(p.id) === String(id) ? { ...p, hidden: true } : p
              );

              render(cache);
              buildCappers(cache);
            } catch (e) {
              alert("Hide failed: " + e.message);
            }
          });
        });
      
        // ---- UNHIDE ----
        feed.querySelectorAll("[data-unhide]").forEach((btn) => {
          btn.addEventListener("click", async () => {
            const id = btn.getAttribute("data-unhide");
            if (!id) return;

            if (!confirm("Unhide this pick for ALL users?")) return;

            try {
              const res = await fetch("/admin/unhide", {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                  "x-mod-token": modToken,
                },
                body: JSON.stringify({ id }),
              });

              const out = await res.json().catch(() => ({}));
              if (!res.ok) throw new Error(out.error || "Unhide failed");

              // ‚úÖ instant UI: unmark hidden in cache
              cache = cache.map((p) =>
                String(p.id) === String(id) ? { ...p, hidden: false } : p
              );

              render(cache);
              buildCappers(cache);
            } catch (e) {
              alert("Unhide failed: " + e.message);
            }
          });
        });
      }

      const countEl = document.getElementById("loadedCount");
      if (countEl) {
        countEl.textContent = filtered.length;

}
    }

    let cache = [];
    let lastSeenId = null;
    let firstLoad = true;

    async function loadAndCache() {
      try {
        const res = await fetch("/picks", {
          headers: modToken
            ? { "x-mod-token": modToken }
            : {}
        });
        const json = await res.json();

        const raw = Array.isArray(json)
          ? json
          : (json.picks || json.data || []);

        const picks = raw.map(normalizePick);

        if (firstLoad) {
          cache = picks;
          render(cache);
          buildCappers(cache);
          firstLoad = false;
          lastSeenId = cache[0]?.id ?? null;
        } else {
          const newOnes = [];

          for (const p of picks) {
            if (lastSeenId === null) break;
            if (p.id === lastSeenId) break;
            newOnes.push(p);
          }

          if (newOnes.length) {
            markNewPicks(newOnes);

            // increment unread for cappers you're NOT currently viewing
            for (const p of newOnes) {
              const capperName = p.channel_name || "Unknown";
              if (selectedCapper && capperName === selectedCapper) continue;
              incUnread(capperName);
            }

            cache = [...newOnes, ...cache].slice(0, 500);
            render(cache);
            buildCappers(cache);
            lastSeenId = cache[0]?.id ?? lastSeenId;
          }
        }

      } catch (e) {
        console.error(e);
      }
    }

    searchEl.addEventListener("input", () => {
      saveUI({ search: searchEl.value });
      render(cache);
      scrollToTop();
    });

    sportEl.addEventListener("change", () => {
      saveUI({ sport: sportEl.value });
      render(cache);
      scrollToTop();
    });
    // Initial load
    loadAndCache();

    // Poll backend every 5 seconds
    setInterval(loadAndCache, 5000);

    // ‚è±Ô∏è Refresh "time ago" labels every minute (no API call)
    setInterval(() => {
      if (cache && cache.length) {
        render(cache);
      }
    }, 60 * 1000);

    // üñ±Ô∏è Click-to-expand embed images
    document.addEventListener("click", (e) => {
      const img = e.target.closest(".embedImg");
      if (!img) return;
      img.classList.toggle("expanded");
    });

  </script>
</body>
</html>

